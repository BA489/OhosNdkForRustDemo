Recently, I was fascinated by the rust language, and on a whim, I wanted to try whether I could run rust-written programs in Hongmeng. Hongmeng NDK already supports C/C++ writing libraries and integrates them into apps, and rust can compile c-compatible interfaces, so in principle, it is feasible to run rust-written programs in Hongmeng in principle.

Hongmeng claims to be able to support a variety of devices, but this project is only for mobile phones, and it is a relatively new mobile phone (to be precise, it is a mobile phone based on aarch64).NDK compilation to different devices requires different cross-compilers (or compilation targets). This project only tries the aarch64-linux-ohos compilation target in Hongmeng NDK.

However, there are still some difficulties in implementation that need to be overcome.The following is a brief introduction to the idea of implementing this project.



## Dependency

-DevEco Studio 3.0 Beta1, available for Windows and macOS.Other versions may work, but there is no test.

  - HarmonyOS Legacy SDK (API version 7)
    - Java
    -JS (this project may not be required, installed by default)
    - Native

- rust

  -It is recommended to use the officially recommended [rustup] (https://rustup.rs /) Way to install

  -This project relies on the nightly tool chain and rust source code：

    ```bash 
    rustup toolchain add nightly
    rustup component add rust-src
    ```



## Implementation method

### Method One

(Method 1 is only used for idea verification. There are no special circumstances. Please move to Method 2 directly. It has fewer dependencies and is more convenient to build and run.)

In order to quickly verify that the library written by rust can be called in Hongmeng mobile phones, considering the similarity between Android and Hongmeng on the mobile phone system, it is conjectured that the binary files compiled by it are compatible.Because if the conjecture is true, first borrow the android tool chain to compile and generate a dynamic connection library, and copy it to Hongmeng for use.Compiling rust code in android is currently well supported, such as [rust-android-gradle] (https://github.com/mozilla/rust-android-gradle ) Plug-in project. However, this plug-in cannot be used directly in DevEco Studio.

In order to achieve one-click build and run, I used [corruption](https://github.com/corrosion-rs/corrosion ) Project, which can integrate rust's compilation process into camke, and then call cmake in gradle to build.The dynamic link library generated by the entire construction process will be automatically packaged.To run this version, you need to check out the first commit in the code base：

```bash
git checkout a88f485b1fb21f7115fa7024c1eecef3ae9e6fa2
```

This method relies on an additional Android development tool chain.And through verification, the rust code of the example can be run, but after all, the NDK provided by Hongmeng is different from the Android NDK, and there is no complete guarantee that the compiled library can be fully compatible.

#### Additional dependency

 -  [corrosion](https://github.com/corrosion-rs/corrosion) 
 - Android Studio
   -NDK 21.4.7075529 or 22.1.7171670
     -Version 23.1.7779620 did not succeed 

### Method Two

The latest version of the code can be built and run with one click.The following briefly introduces some technical points to achieve this process.

Method 1 verifies that Hongmeng mobile phones can indeed load the dynamic connection library compiled by rust (although it is compiled by the borrowed Android cross compiler). Hongmeng's NDK also provides a cross compiler. Of course, a natural idea is to directly use Hongmeng's own cross tool chain.

#### Rust Custom compilation target

To cross-compile rust code to Hongmeng, you need to customize the compilation target.Although in principle, we only need to cross-compile the connectors in the tool chain to connect the object files compiled by rustc to the dynamic link library we need, this does not mean that everything will be fine if we modify the default connector to a cross-compiler connector.Since rust's jni crate relies on std, there is no official precompiled std crate for the Hongmeng system, so we need to compile it ourselves.It is not easy to cross-compile std and its dependent crates for non-rust official built-in compilation targets.This requires a target specification file that describes the various properties of the target system.Even if the target system can be described well, it is likely that the complete cross-compilation of std will not be completed, because some underlying libraries, such as libc and FFI, need to be adapted to some interface code in order to fully ensure compatibility.A risk method is used here, which will be mentioned again at the end of this section.

I mainly refer to [this article] (https://docs.rust-embedded.org/embedonomicon/custom-target.html ) and [this article] (https://github.com/japaric/rust-cross ) The document is cross-compiled for the entire project. The cargo tool is usually used for the construction of rust projects. The compilation target is specified through the--target parameter. When not specified, it is compiled to the default target of the machine by default. For example, it is compiled to 'x86_64-apple-darwin` by default on my macOS.

```bash
$ rustc -vV | grep host
host: x86_64-apple-darwin
```

When we want to compile to android, we can execute code of type l (in fact, other additional configurations may be required, such as the location of linker in Android NDK, before the command can be executed successfully. This is not the focus of the current discussion, so ignore it first)

```bash
cargo build --target aarch64-linux-android
```

Since Hongmeng has not been officially supported by rust, there are no built-in compilation targets such as `aarch64-linux-android` and `x86_64-apple-darwin` that can be used directly.In order to cross-compile to Hongmeng, you need to customize the target of cross-compilation.A compilation target can be described by a json file. We call this json file the **specification** of the target system.To create a target specification, the recommended method is to modify the **Built-in target specification** similar to the target system.The way to modify is to adjust the attribute value in the specification to match the attribute of the target system.In view of the similarity between the Hongmeng mobile phone system and the android system, we use the built-in target `aarch64-linux-android` to modify it.The specifications of the built-in target can be obtained by the following command：

```bash
$ rustc +nightly -Z unstable-options --print target-spec-json --target aarch64-linux-android
{
  "arch": "aarch64",
  "data-layout": "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128",
  ...
  ...
  "target-pointer-width": "64"
}
```

In order to obtain the default parameters in the Hongmeng NDK compilation connection process, we can create a Native C++ project in DevEco Studio. In Debug mode, after compilation, `compile_commands.` will be generated in the'entry/debug/arm64-v8a/' directory.json' file, we can find the default command line for compiling C++ files in this file, parse out the required parameters from this command line, and add them to the `pre-link-args` and`post-link-args` in the specification file.In addition, you also need to add attributes such as `linker`,`linker-flavor`.`linker` is the name of the connector command we want to call. `linker-flavor` specifies the “style” of the parameters accepted by the connector. It is the value that cargo needs when it generates the connector parameter form for us. It is estimated that the parameter format acceptable to the connector does not have a formal definition, so the word “flavor” is used. The values that can be set by 'linker-flavor` can be found in [here] (https://doc.rust-lang.org/rustc/codegen-options/index.html#linker-flavor ). The following is a simple example to illustrate the role of the "linker-flavor" parameter: When we want to connect to the "m` library，

-If`linker-flavor` is set to`ld`, cargo may generate the connector parameter for us as`-lm`
-If`linker-flavor` is set to 'gcc`, cargo may generate the connector parameters for us as`-Wl,-lm`

##### Potential risks in custom target specification files

A potential risk needs to be explained here. In the specification file, we keep `"os" = "android"`.After trying, modifying to other values such as linux will not work for the time being.When modified to linux, it will cause an error in compiling libc crate.This means that when compiling libc crate in rust, the source code on the rust side used is actually tailored for libc in Android.If the definition of libc in Android is consistent with the external types, data, and interfaces of Hongmeng's libc, then there will be no problem, otherwise unexpected errors will occur.This involves some low-level things. In principle, the definition of the rust side is required to be consistent with the definition of the c side (the definition of each type in the header file), so that the things compiled by RUSTC can be consistent with the ones provided by NDK. libc.so Compatible, in order to seamlessly call the c library from rust.Because the bottom layer is connected to this c library libc.so . Currently, rust's libc crate does not support Hongmeng.Unless Hongmeng continues to grow frantically and reaches the level of Android, it is estimated that rust officials will not provide support for Hongmeng.Or Huawei supports rust and submits support code for basic crates such as libc.Due to the existence of this risk, compatibility cannot be guaranteed, and this project may always be used as an example and cannot be used in real production scenarios.

#### Build script

We wrote a one-click build script for the rust code part, and asked gradle to call the build script to achieve a one-click build of the entire project.In addition, the build script has some important functions. For example, some important parameters of the connector, such as`--gcc-toolchain` and`--sysroot` are not suitable for placement in the specification file, especially when sharing and using the specification file on different systems.Because they involve the location of NDK installation.Different users and different operating systems may have different installation locations. If they are hard-coded into the specification file, the target specification file cannot be reused well.Through the build script, the installation location of NDK can be passed in by gradle in the form of parameters.In the build script, you can freely calculate the various required paths based on the NDK installation directory, and pass them to cargo in the form of environment variables or parameters. See rust's build script for details`entry/src/main/rust/build.sh `or'build.bat`.

##### How to deal with unsupported options

Using `"os" = "android"`, cargo will insert the option`-llog` for the connection to the log library by default when generating the connection command line. In Hongmeng's NDK, there is no` liblog.so `File (the target library file is`hilog_ndk.z.so `?), this will cause an error that the library file cannot be found when connecting. One way is to create to`hilog_ndk.z.so 'Of the soft connection and named`liblog.so `, as long as you don't use it`liblog.so 'Just the things defined in'.However, doing so requires the user to modify the NDK directory by themselves. You cannot simply clone the warehouse and run it directly.

In order to solve this problem, I wrote a connector wrapper that accepts compilation parameters, filters out unsupported options, and then passes it to the real connector.This part of the code is a small rust project, see `entry/src/main/tool`. What is more interesting is that under Windows, due to the very strict length limit of the command line, and the command line generated by cargo is usually very long, the command line parameters passed to the connector will be automatically dumped into a temporary file, and then the temporary file will be [response file] (https://llvm.org/docs/CommandLine.html#response-files ) Is passed to the connector in the form of, resulting in different ways of handling command-line parameters on macOS and Windows. Specific questions can be seen [here] (https://stackoverflow.com/questions/40727748/windows-clang-command-line-too-long ). I originally thought that rust could be developed across platforms, but Windows' strange processing logic broke the consistency, and Windows was disgusted again.

#### Other pits

Finally, it seems to me that the naming of the specification file will also have an impact on the connection command generated by cargo, see [here] (https://github.com/rust-lang/wg-cargo-std-aware/issues/60 ). I discovered it by accident when I used the `aarch64-unknown-linux-gnu` target as the basis for the Hongmeng target specification file.My current understanding is that for custom targets, the best way to name them is to add other fields after the target name, for example, `aarch64-unknown-linux-gnu-ohos.json`, or when building, provide ['CARGO_CFG_TARGET_*'series of environment variables] (https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts ) The value. Since the creation of the Hongmeng target specification file from `aarch64-unknown-linux-gnu` was unsuccessful, it may be because of the large difference in libc, and finally a connection error occurred. I won't talk about it in detail here.

References
https://github.com/mozilla/rust-android-gradle
https://github.com/japaric/rust-cross
https://github.com/corrosion-rs/corrosion
https://doc.rust-lang.org/rustc/codegen-options/index.html#linker-flavor
https://llvm.org/docs/CommandLine.html#response-files

Original Author: cyc via Gitee for OhosNdkForRustDemo: https://gitee.com/expnn/ohos-ndk-for-rust-demo
